import fs from "node:fs/promises";
import path from "node:path";
import exifr from "exifr";
import sharp from "sharp";

async function pathExists(p) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}

async function main() {
  const projectRoot = process.cwd();
  const sourceDir = path.join(projectRoot, "cindy");
  const targetDir = path.join(projectRoot, "public", "cindy");

  const sourceExists = await pathExists(sourceDir);
  if (!sourceExists) {
    console.warn(`[sync-assets] Source folder not found: ${sourceDir}`);
    console.warn(
      "[sync-assets] Nothing to sync. If you want photos, add them to ./cindy or place them in ./public/cindy",
    );
  } else {
    await fs.mkdir(targetDir, { recursive: true });

    const entries = await fs.readdir(sourceDir, { withFileTypes: true });
    const files = entries.filter((e) => e.isFile()).map((e) => e.name);

    let copied = 0;
    let skipped = 0;

    for (const filename of files) {
      const from = path.join(sourceDir, filename);
      const to = path.join(targetDir, filename);

      const alreadyThere = await pathExists(to);
      if (alreadyThere) {
        skipped += 1;
        continue;
      }

      await fs.copyFile(from, to);
      copied += 1;
    }

    console.log(
      `[sync-assets] Synced cindy photos → public/cindy (copied: ${copied}, skipped: ${skipped})`,
    );
  }

  await generatePhotoMetadata({ projectRoot, photosDir: targetDir });
  await generateSdrWebPhotos({ projectRoot, photosDir: targetDir });
  await generatePhotoThumbnails({ projectRoot, photosDir: targetDir });
}

function toDateOnlyStringFromExif(value) {
  if (!value) return null;
  if (value instanceof Date && !Number.isNaN(value.getTime())) {
    const y = value.getFullYear();
    const m = String(value.getMonth() + 1).padStart(2, "0");
    const d = String(value.getDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }

  // Common EXIF string format: "YYYY:MM:DD HH:MM:SS"
  if (typeof value === "string") {
    const match = value.match(/^(\d{4}):(\d{2}):(\d{2})/);
    if (!match) return null;
    const [, y, m, d] = match;
    return `${y}-${m}-${d}`;
  }

  return null;
}

async function generatePhotoMetadata({ projectRoot, photosDir }) {
  const appDir = path.join(projectRoot, "app");
  const outputFile = path.join(appDir, "photoMeta.generated.js");

  const photosDirExists = await pathExists(photosDir);
  if (!photosDirExists) {
    console.warn(`[sync-assets] Photos folder not found: ${photosDir}`);
    console.warn("[sync-assets] Skipping metadata generation.");
    return;
  }

  let photos = [];
  try {
    // Pull the canonical list from app/photos.js (keeps ordering consistent with the UI).
    const mod = await import(new URL("../app/photos.js", import.meta.url));
    photos = Array.isArray(mod.photos) ? mod.photos : [];
  } catch (err) {
    console.warn("[sync-assets] Could not import app/photos.js; falling back to directory scan.");
    const entries = await fs.readdir(photosDir, { withFileTypes: true });
    photos = entries.filter((e) => e.isFile()).map((e) => e.name);
  }

  const metaByFilename = {};

  for (const filename of photos) {
    const fullPath = path.join(photosDir, filename);
    const exists = await pathExists(fullPath);
    if (!exists) continue;

    let takenAt = null;
    try {
      const buf = await fs.readFile(fullPath);
      const tags = await exifr.parse(buf, {
        pick: ["DateTimeOriginal", "CreateDate", "ModifyDate"],
      });

      takenAt =
        toDateOnlyStringFromExif(tags?.DateTimeOriginal) ||
        toDateOnlyStringFromExif(tags?.CreateDate) ||
        toDateOnlyStringFromExif(tags?.ModifyDate);
    } catch {
      // ignore (some formats may not parse)
    }

    if (!takenAt) {
      try {
        const st = await fs.stat(fullPath);
        takenAt = toDateOnlyStringFromExif(st.mtime);
      } catch {
        takenAt = null;
      }
    }

    metaByFilename[filename] = { takenAt };
  }

  const sortedKeys = Object.keys(metaByFilename).sort((a, b) => a.localeCompare(b));
  const sortedObject = Object.fromEntries(sortedKeys.map((k) => [k, metaByFilename[k]]));

  const contents = `// This file is (re)generated by \`npm run sync-assets\`.
// It is safe to commit. If you add/remove photos, run the script again.
export const relationshipStartDate = "2025-05-24";

// Map: filename -> metadata
// takenAt is a date-only string (YYYY-MM-DD) derived from EXIF when possible.
export const photoMetaByFilename = ${JSON.stringify(sortedObject, null, 2)};
`;

  await fs.writeFile(outputFile, contents, "utf8");
  console.log(`[sync-assets] Wrote photo metadata → ${path.relative(projectRoot, outputFile)}`);
}

function toThumbFilename(filename) {
  // Normalize all thumbnails to .jpg (smaller + broadly supported)
  return String(filename).replace(/\.[^.]+$/, ".jpg");
}

function toWebFilename(filename) {
  // Normalize all web display images to .jpg (smaller + broadly supported)
  return String(filename).replace(/\.[^.]+$/, ".jpg");
}

async function loadCanonicalPhotosList({ projectRoot, photosDir }) {
  let photos = [];
  try {
    // Pull the canonical list from app/photos.js (keeps ordering consistent with the UI).
    const mod = await import(new URL("../app/photos.js", import.meta.url));
    photos = Array.isArray(mod.photos) ? mod.photos : [];
  } catch {
    const entries = await fs.readdir(photosDir, { withFileTypes: true });
    photos = entries.filter((e) => e.isFile()).map((e) => e.name);
  }
  return photos;
}

async function generateSdrWebPhotos({ projectRoot, photosDir }) {
  const photosDirExists = await pathExists(photosDir);
  if (!photosDirExists) return;

  const webDir = path.join(photosDir, "_web");
  await fs.mkdir(webDir, { recursive: true });

  const photos = await loadCanonicalPhotosList({ projectRoot, photosDir });

  // Big enough for most phones, much smaller than originals.
  const maxDim = 2200;
  let generated = 0;
  let skipped = 0;

  for (const filename of photos) {
    const from = path.join(photosDir, filename);
    const exists = await pathExists(from);
    if (!exists) continue;

    const outName = toWebFilename(filename);
    const to = path.join(webDir, outName);

    // Skip if web image is newer than source.
    const alreadyThere = await pathExists(to);
    if (alreadyThere) {
      try {
        const [srcStat, dstStat] = await Promise.all([fs.stat(from), fs.stat(to)]);
        if (dstStat.mtimeMs >= srcStat.mtimeMs) {
          skipped += 1;
          continue;
        }
      } catch {
        // fall through and regenerate
      }
    }

    // Convert to SDR (sRGB) and strip HDR/gain-map metadata by re-encoding.
    await sharp(from)
      .rotate() // apply EXIF orientation
      .resize({
        width: maxDim,
        height: maxDim,
        fit: "inside",
        withoutEnlargement: true,
      })
      .toColourspace("srgb")
      .jpeg({ quality: 80, mozjpeg: true })
      .toFile(to);

    generated += 1;
  }

  console.log(
    `[sync-assets] Generated SDR web photos → public/cindy/_web (generated: ${generated}, skipped: ${skipped})`,
  );
}

async function generatePhotoThumbnails({ projectRoot, photosDir }) {
  const photosDirExists = await pathExists(photosDir);
  if (!photosDirExists) return;

  const thumbsDir = path.join(photosDir, "_thumbs");
  await fs.mkdir(thumbsDir, { recursive: true });

  const photos = await loadCanonicalPhotosList({ projectRoot, photosDir });
  const webDir = path.join(photosDir, "_web");

  const size = 96; // px (good balance for 24–44px dots)
  let generated = 0;
  let skipped = 0;

  for (const filename of photos) {
    const fromWeb = path.join(webDir, toWebFilename(filename));
    const fromOriginal = path.join(photosDir, filename);
    const useWeb = await pathExists(fromWeb);
    const from = useWeb ? fromWeb : fromOriginal;

    const exists = await pathExists(from);
    if (!exists) continue;

    const thumbName = toThumbFilename(filename);
    const to = path.join(thumbsDir, thumbName);

    // Skip if thumbnail is newer than the source.
    const alreadyThere = await pathExists(to);
    if (alreadyThere) {
      try {
        const [srcStat, dstStat] = await Promise.all([fs.stat(from), fs.stat(to)]);
        if (dstStat.mtimeMs >= srcStat.mtimeMs) {
          skipped += 1;
          continue;
        }
      } catch {
        // fall through and regenerate
      }
    }

    await sharp(from)
      .resize(size, size, { fit: "cover" })
      .toColourspace("srgb")
      .jpeg({ quality: 62, mozjpeg: true })
      .toFile(to);
    generated += 1;
  }

  console.log(
    `[sync-assets] Generated photo thumbnails → public/cindy/_thumbs (generated: ${generated}, skipped: ${skipped})`,
  );
}

await main();

